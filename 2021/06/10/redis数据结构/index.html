<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>redis数据结构 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Redis数据结构1.SDS（简单动态字符串）本质上这是算法里面的使用空间换取时间的做法，相比于C语言里面的字符数组（注意不是字符串string），Redis里面的字符串多添加了字符串长度的值（len）以及记录了数组所剩余的空间（free），这样的话在访问字符串长度的时候就不需要遍历整个数组了，同时在内存分配上会做的更好。 记录数组所剩余的空间可以保证在字符串进行相加的时候不会溢出导致与其他内存地">
<meta property="og:type" content="article">
<meta property="og:title" content="redis数据结构">
<meta property="og:url" content="http://example.com/2021/06/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis数据结构1.SDS（简单动态字符串）本质上这是算法里面的使用空间换取时间的做法，相比于C语言里面的字符数组（注意不是字符串string），Redis里面的字符串多添加了字符串长度的值（len）以及记录了数组所剩余的空间（free），这样的话在访问字符串长度的时候就不需要遍历整个数组了，同时在内存分配上会做的更好。 记录数组所剩余的空间可以保证在字符串进行相加的时候不会溢出导致与其他内存地">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-10T08:35:20.000Z">
<meta property="article:modified_time" content="2024-10-05T08:25:54.269Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-redis数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-06-10T08:35:20.000Z" itemprop="datePublished">2021-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      redis数据结构
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="1-SDS（简单动态字符串）"><a href="#1-SDS（简单动态字符串）" class="headerlink" title="1.SDS（简单动态字符串）"></a>1.SDS（简单动态字符串）</h2><p>本质上这是算法里面的使用空间换取时间的做法，相比于C语言里面的字符数组（注意不是字符串string），Redis里面的字符串多添加了字符串长度的值（len）以及记录了数组所剩余的空间（free），这样的话在访问字符串长度的时候就不需要遍历整个数组了，同时在内存分配上会做的更好。</p>
<p>记录数组所剩余的空间可以保证在字符串进行相加的时候不会溢出导致与其他内存地址的元素产生冲突，主要是，字符数组在进行数组拓充的时候要保证不会干涉到其他内存里面的元素，类比于OS里面的内存分配算法，你要是多分配了空间可能需要集体转移走这部分空间，产生系统调用。这不符合redis这快速的理念。记录下来可以就保证即使超出了字符数组只要添加进来的元素不大于free就不需要系统调用。那万一大于呢？这个时候就必须进行空间预分配，具体的：</p>
<ol>
<li>添加的长度小于1MB，长度变成了x,则多分配x，最终长度为$2 \times x+1bit$。</li>
<li>大于1MB的时候，长度变成了x，则只多分配1MB，最终为$x+1MB+1bit$。</li>
</ol>
<p>那对应删除字符串里面的元素，则不对整个SDS做空间上的处理，只更新free，不更新len。但是我们依然可以调用函数来修改len保证可以释放内存。</p>
<p>同时SDS是二进制安全的，就是可以存放空格，而C语言的字符数组不可以。</p>
<p>最后SDS可以调用一些C语言的代码来与C语言的字符数组做比较。</p>
<h3 id="API的实现"><a href="#API的实现" class="headerlink" title="API的实现"></a>API的实现</h3><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><p>Reids链表主要是双端无环的链表，可以前后移动，同时又一个头指针与尾指针，且还记录了整个链表的长度，同时还记录了dup,free,macth三种不同的函数。</p>
<ul>
<li>dup:节点值复制函数</li>
<li>free:节点值释放函数</li>
<li>match:节点值对比函数</li>
</ul>
<h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3.字典"></a>3.字典</h2><h3 id="3-1字典实现"><a href="#3-1字典实现" class="headerlink" title="3.1字典实现"></a>3.1字典实现</h3><p>实现顺序为：哈希表+哈希节点-&gt;字典</p>
<h4 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h4><p>不同于大学里面的数据结构学习的简单哈希表，这里它是先在外面存储了三个字段size,sizemask,used,size就是哈希表的长度，sizemask&#x3D;size-1，用来计算索引值，就是数据结构中哈希表长n,则在计算的时候需要mod n-1。used就是哈希表里面装有多少个元素。由于它这个哈希表使用的是链地址法，因此这个used的值是可能大于size的。</p>
<h4 id="哈希节点："><a href="#哈希节点：" class="headerlink" title="哈希节点："></a>哈希节点：</h4><p>就是链地址里面的链表结构。这里存储了它的key和value以及它的下一个节点地址。注意记得是map[key]&#x3D;value。</p>
<p>计算冲突节点：链地址法解决冲突，唯一需要注意的是新节点在链地址前旧节点在链地址的后面，找到旧节点会慢一点。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>由type,privdata和两个哈希表组成。</p>
<p>type：</p>
<p>privdata：保存函数？</p>
<p>为什么需要两个哈希表？有一个确实就是用来记录存储哈希值的。另一个在没有进行rehash的时候为空。而rehash操作是值要增加或者释放哈希表所占用的空间。我们多用一个哈希表就是来copy这个原来的哈希表的。可以理解为swap交换元素的时候的那个租借元素t。</p>
<h3 id="解决散列表冲突"><a href="#解决散列表冲突" class="headerlink" title="解决散列表冲突"></a>解决散列表冲突</h3><p>链地址法</p>
<h3 id="计算哈希"><a href="#计算哈希" class="headerlink" title="计算哈希"></a>计算哈希</h3><p>Murmurhash算法：</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>rehash操作是值要增加或者释放哈希表所占用的空间。就是不希望它占用太多的内存或者不够内存。</p>
<p>在进行拓大的时候：就是增加到这个哈希表长度的两倍对应的$2^n$的那个值。比如，旧的哈希表used个数为7,则$2 \times 7&#x3D;14$ 14-&gt;16($2^4$)，则新的哈希表大小就为16，假如旧的哈希表used个数为9,则$2 \times 9&#x3D;18$ 18-&gt;32($2^5$)，则新的哈希表大小就为32.</p>
<p>缩小的时候：就是设定为到这个哈希表长度的对应的$2^n$的那个值。比如，旧的哈希表used个数为7,则 7-&gt;8($2^3$)，则新的哈希表大小就为8，假如旧的哈希表used个数为9,则9-&gt;16($2^4$)，则新的哈希表大小就为16.</p>
<p>迁移的时候，根据分配的那个新的空间进行重新计算哈希表的值然后分配到新的哈希表中，然后在计算完成迁移完所有数据后，然后把原来的那个哈希表弄为空。而整个rehash的过程是渐进式的。就是它rehash的时候同时也得保证正常的基础服务比如增删改查能够执行。假如不这么做就为了rehash这一个动作服务器拷贝上千万条数据需要过多的时间。</p>
<p>具体怎么做呢？就是你在rehash的时候，在由增删改查操作的时候，在对这个哈希表进行操作的时候，同时也将该数据拷贝到新建的哈希表那里，然后我们在外面设置一个字段rehashidx的值，一开始为0，然后每进行上述操作的时候我们就对其加一（rehashidx++）直到完全拷贝完以后把这个字段变成-1表示rehash操作完成。同时我们在rehash期间假如要新加一组元素进去，我们就直接保存在新的哈希表中，原来的哈希表就不添加。这就导致假如我们查询的过程是需要同时遍历两个表的。假如旧哈希表找不到就还得去新的哈希表里面找。</p>
<h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4.跳跃表"></a>4.跳跃表</h2><p>由于大学课本里面的数据结构并没有涉及跳跃表，因此这里我必须先讲下跳跃表是什么，然后再讲redis里面的跳跃表是怎么实现的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/helloworld_ptt/article/details/105801262">https://blog.csdn.net/helloworld_ptt/article/details/105801262</a> 这篇文章讲解的很详细，有从链表到跳跃表的整个演变过程，同时解释了跳跃表为什么性能可以。这里再具体的引用下里面的说明：</p>
<ul>
<li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）</li>
<li>如果一个节点有第i层(i&gt;&#x3D;1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的<strong>概率为p</strong></li>
<li>节点最大的层数不允许超过一个最大值，记为<strong>MaxLevel</strong><br>这个计算随机层数的伪码如下所示：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    level := 1</span><br><span class="line">    // random()返回一个[0...1)的随机数</span><br><span class="line">    while random() &lt; p and level &lt; MaxLevel do</span><br><span class="line">        level := level + 1</span><br><span class="line">    return level</span><br></pre></td></tr></table></figure>

<p>也就是说每个节点它拥有的指针并不是均等的，而是符合于几何分布。</p>
<p>在 redis里面，层高是1到32的随机数</p>
<p>接下来我们就介绍redis里面跳跃表的实现的。跳跃表是有序的，因此我们这里假设其为从小到大的顺序进行排列。则跳跃表其包括zskiplist与zskiplistNode两个结构。</p>
<p><strong>zskiplist</strong>用来保存整个跳跃表的信息，记录了跳跃表的首尾指针，同时记录了这个跳跃表里面最多指针的个数，还有这个跳跃表的长度。</p>
<p><strong>zskiplistNode</strong>则保存的就是其节点信息以及指针。而值得注意的是，这每一个指针出了记录指向下一个节点的地址，还记录了去这个地址所需要的长度，比如这个指针指向的就是它下一个恰好大于它的那个数的地址，则这个指针的跨度就为1，以此类推。记录了这个跨度有个好处，在我们遍历的时候，我们可以通过累加得到最终查找的那个元素在整个跳跃表中的排位。而同时zskiplistNode里面还包含了后退指针用来先前遍历的，但是一次只能后退到恰好小于它那个数的地址。</p>
<p>其实这个在实际外露效果来说和优先队列是一样的，而优先队列用的是堆。总之是一种比较特别的数据结构。</p>
<h2 id="5-整数集合-intset"><a href="#5-整数集合-intset" class="headerlink" title="5.整数集合(intset)"></a>5.整数集合(intset)</h2><p>相比于集合，其更加严苛：</p>
<ol>
<li>只包含整数值</li>
<li>集合的数量不多</li>
</ol>
<p>redis使用intset保存元素，其数据结构有别于我平时学到的数据结构。如下：</p>
<ul>
<li><strong>encoding</strong>:用来保存编码方式，int16 int32 int64。这样做最大的好处是可以节约内存，需要用到int64的数字才去使用，且同时保证了数据的存储是稳定的（就让他是数组的样子可以随机读取），不会即使都是int类型但是由于int的大小不一样导致无法随机读取。</li>
<li>length：数组长度</li>
<li>contents[]：数组，这个数组里面的元素是有序的，因此我们在寻找整数集合里面的元素的时候可以使用二分查找</li>
</ul>
<h4 id="整数集合升级"><a href="#整数集合升级" class="headerlink" title="整数集合升级"></a>整数集合升级</h4><p>encoding最有用的地方就在这里：我们一开始假如保存的数据都可以拿int16保存，那encoding就选择为int16。问题是，我突然来了一个int32才能保存的数字，怎么办？这个时候就需要升级，把原来保存的元素从int16升级为int32。具体怎么升级，和上面的字典是不一样的。字典是多用了一个哈希表来存储新的数据来达到rehash，而这里我们是直接拓充数组的空间，来完成升级。比如：我有三个int16的元素，现在来了一个int32的元素,由于我知道每个元素大小是多少且保存了元素的长度，我可以直接在数组的末端添加$4\times32-3\times16&#x3D;80$bit空间来完成升级。而此时你可能会有疑惑，拓充完之后岂不是得重新把新元素插入进行排序？大可不必！假如需要升级，这个新元素的值要么是大于所有现有元素，要么就是小于所有现有元素（int的范围可是包括负数的）。假如是大于所有现有元素，这个新元素就放在contents最末尾，反之放在最前面。对于原来的元素，只需要从后往前的把类型升级然后保存到升级后应该在的位置就可（因为最后面的位置是空的，因此得把高位的元素先放到后面才能挪出空间给前面的元素放，不然会直接破坏掉后面的元素的值）。</p>
<h3 id="整数集合没有降级"><a href="#整数集合没有降级" class="headerlink" title="整数集合没有降级"></a>整数集合没有降级</h3><p>要是把升级完int32后又把所有只能用int32表示的数删除了，整数集合依然不会降级。</p>
<h3 id="整数集合API"><a href="#整数集合API" class="headerlink" title="整数集合API"></a>整数集合API</h3><h2 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.压缩列表"></a>6.压缩列表</h2><p>该数据结构是用来实现列表键和哈希键的底层。当列表键包含：</p>
<ol>
<li>少量列表项</li>
<li>每个列表项要么是小整数值，要么是长度短的字符串</li>
</ol>
<p>压缩列表就如其名字所说，就是专门为了压缩数据，降低存储成本来制造的，其数据结构如下图所示:</p>
<table>
<thead>
<tr>
<th>zlbytes</th>
<th>zltail</th>
<th>zllen</th>
<th>entry1</th>
<th>entry2</th>
<th>…</th>
<th>entryn</th>
<th>zlend</th>
</tr>
</thead>
</table>
<p>zlbytes:记录整个数据结构的内存</p>
<p>zltail：注意，这里并不是记录这个尾节点的地址，而是偏移地址（用计组的话来说）</p>
<p>zllen：记录所占据的节点，但是只有两个字节，要是节点数大于65536则需要遍历整个列表</p>
<p>zlend：列表末端</p>
<p>entry：其结构如下图所示：</p>
<table>
<thead>
<tr>
<th>previous_entry_length</th>
<th>encoding</th>
<th>content</th>
</tr>
</thead>
</table>
<p>previous_entry_length:记录前一个节点的长度，可以通过本节点往前进行遍历。</p>
<ol>
<li>长度小于254：一个字节</li>
<li>大于254：5个字节，第一个为254，后面才是长度</li>
</ol>
<p>encoding：编码方式</p>
<p>保存字符数组：用1字节&#x2F;2字节&#x2F;5字节来表示 前两位为编码 00：length&lt;&#x3D;63（7位的1） 01：length&lt;&#x3D;16383(14位的1)，10：length&lt;&#x3D;(29位的1)</p>
<p>整数编码：就一个字节</p>
<p>content：内容</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>什么情况下会更新的比较慢呢？由于压缩列表里面每个节点的大小是可以改变的，而每个节点又记录了前一个节点的大小，前面节点大小改变可能会导致后面存储前面的大小也进行改变。</p>
<p>由于我们用1字节表示length&lt;254的节点，用五字节表示length&gt;&#x3D;254的节点。就会导致多个连续的长度在250到253节点之间的节点，假如在第一个节点前面插入一个length&gt;&#x3D;254的节点，然后导致entry1的pre无法用1字节存储，被迫拓展，则它自己长度也变成&gt;&#x3D;254，然后就会递归的往后进行更新。当然实际上很难出现这种情况，所有整体复杂°压缩列表还是可以的。而这最坏的时间复杂度为o($n^2$)。实际过程中压缩列表的复杂度都是为O（n）。其实它挺像链表的，链表可以无序存放（即可以不需要连续存储），但是压缩列表是需要的。</p>
<h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm1vw3qdx0000lg7uec66cm4p" data-title="redis数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/05/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 10px;">原创</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/06/10/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis数据结构</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>